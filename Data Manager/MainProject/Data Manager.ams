## ams_version=1.0

Model Main_Data_Manager {
    Section Model_Section {
        DeclarationSection Quantity_Declaration {
            Quantity Volume {
                BaseUnit: dm3;
                Conversions: l -> dm3 : # -> #;
            }
            Quantity Surface {
                BaseUnit: dm2;
            }
            Quantity Money {
                BaseUnit: $;
            }
            Quantity Mass {
                BaseUnit: kg;
            }
        }
        DeclarationSection Constant_Input_Declaration {
            Set Products {
                Index: p;
            }
            Set Materials {
                Index: m;
            }
            UnitParameter MaterialUnit {
                IndexDomain: (m);
                Text: "Unit";
            }
            UnitParameter ProductUnit {
                IndexDomain: (p);
                Text: "Unit";
            }
            Parameter MaterialContentsInProduct {
                IndexDomain: (p,m);
                Range: nonnegative;
                Unit: MaterialUnit(m)/ProductUnit(p);
            }
        }
        DeclarationSection Variable_Input_Declaration {
            Parameter MaterialCost {
                IndexDomain: (m);
                Text: "Cost";
                Range: nonnegative;
                Unit: $/MaterialUnit(m);
            }
            Parameter AvailableMaterial {
                IndexDomain: (m);
                Text: "Available";
                Range: nonnegative;
                Unit: MaterialUnit(m);
            }
            Parameter Demand {
                IndexDomain: (p);
                Range: nonnegative;
                Unit: ProductUnit(p);
            }
            Parameter Revenue {
                IndexDomain: (p);
                Range: nonnegative;
                Unit: $/ProductUnit(p);
            }
            Parameter ProductCost {
                IndexDomain: (p);
                Unit: $/ProductUnit(p);
                Property: NoSave;
                Definition: sum(m, MaterialContentsInProduct(p,m) * MaterialCost(m));
            }
        }
        DeclarationSection Output_Declaration {
            Variable Production {
                IndexDomain: (p);
                Range: integer;
                Unit: ProductUnit(p);
            }
            Variable ProductionCost {
                Unit: $;
                Definition: sum((m,p), MaterialCost(m) * MaterialContentsInProduct(p,m) * Production(p));
            }
            Variable Profit {
                Unit: $;
                Definition: sum(p, Revenue(p) * Production(p));
            }
            Variable ObjectiveValue {
                Unit: $;
                Definition: Profit - ProductionCost;
            }
            Variable MaterialUsed {
                IndexDomain: (m);
                Unit: MaterialUnit(m);
                Definition: sum(p, Production(p) * MaterialContentsInProduct(p,m));
            }
        }
        DeclarationSection Model_Declaration {
            Constraint AvailableMaterialConstraint {
                IndexDomain: (m);
                Unit: MaterialUnit(m);
                Definition: sum(p, Production(p) * MaterialContentsInProduct(p,m)) <= AvailableMaterial(m);
            }
            Constraint ProductionBelowDemand {
                IndexDomain: p;
                Unit: ProductUnit(p);
                Definition: Production(p) <= Demand(p);
            }
            MathematicalProgram MaximizeProfit {
                Objective: ObjectiveValue;
                Direction: maximize;
            }
        }
    }
    Section Data_Manager_Section {
        DeclarationSection Data_Manager_Declaration {
            Parameter OK;
            ElementParameter ThisCase {
                Range: AllCases;
            }
            ElementParameter ThisDataset {
                Range: AllDataSets;
            }
            StringParameter DataFileName {
                IndexDomain: (IndexDataFiles);
            }
            StringParameter CaseName;
            StringParameter CasePath;
        }
        DeclarationSection Current_Data_Declaration {
            StringParameter CurrentConstantInput {
                Definition: DataFileName(CurrentDataset('Constant Input'));
            }
            StringParameter CurrentVariableInput {
                Definition: DataFileName(CurrentDataset('Variable Input'));
            }
            StringParameter CurrentCaseName {
                Definition: DataFileName(CurrentCase);
            }
        }
        Procedure StartupProcedure {
            Body: {
                for IndexCases do
                	CaseGetType(IndexCases, CaseType(IndexCases))
                endfor ;
                
                ThisCase := First( InputCases ) ;
                
                CaseSetChangedStatus(0) ;
                
                CaseLoadCurrent(ThisCase, 0) ;
            }
        }
        Procedure EmptyModelDeclaration {
            Body: {
                Ok := DialogAsk( "The current data will be emptied. Do you want to continue?", "Yes", "No" ) ;
                if OK = 2 then halt endif ;
                
                empty Model_Section ;
                cleandependents ;
                CaseSetChangedStatus(0) ;
                
                for IndexDataCategories do
                	DatasetSetChangedStatus(IndexDataCategories, 0)
                endfor ;
                
                ThisDataset := '' ;
            }
        }
        Procedure OpenVariableDataSet {
            Body: {
                if not DontShowMessageAgain then
                	PageOpen('Load Variable Input') ;
                endif ;
                
                ThisDataset := '' ;
                DatasetLoadCurrent('Variable Input', ThisDataset, 1) ;
            }
        }
        DeclarationSection OpenVariableDataset_Declaration {
            Parameter DontShowMessageAgain {
                InitialData: 0;
            }
        }
        Procedure OpenConstantDataSet {
            Body: {
                DatasetLoadCurrent('Constant Input', ThisDataset, 1) ;
            }
        }
        Procedure SaveVariableInput {
            Body: {
                cleandependents;
                DatasetSaveAs('Variable Input', ThisDataset) ;
            }
        }
        Procedure SaveConstantInput {
            Body: {
                cleandependents;
                DatasetSaveAs('Constant Input', ThisDataset) ;
            }
        }
        Procedure SaveCase {
            Body: {
                cleandependents;
                CaseSaveAs(ThisCase) ;
                
                MainInitialization ;
            }
        }
    }
    Section Batch_Run_Section {
        Procedure OpenBatchrun {
            Body: {
                empty OutputCases ;
                for IndexCases do
                	CaseGetType(IndexCases, CaseType(IndexCases))
                endfor ;
                
                empty OutputCases ;
                PageOpen('Batchrun') ;
            }
        }
        Procedure BatchRun {
            Body: {
                empty OutputCases ;
                cleandependents ;
                PageRefreshAll ;
                
                ! You can use the Batchrun facility in AIMMS, but  you can also create your own batchrun:
                
                ! If you don't want to save the current case and datasets:
                
                	CaseSetChangedStatus(0) ;
                	for IndexDataCategories do DatasetSetChangedStatus(IndexDataCategories, 0) endfor ;
                
                
                ! For all selected input cases, load the case and run MainExecution:
                
                	for ( IndexCases in BatchRunCases ) do
                
                		ThisCase := IndexCases ;
                		CaseLoadCurrent(ThisCase,0) ;
                		MainExecution ;
                		OutputCases += ThisCase ;
                		ObjResult(ThisCase) := Profit ;
                		PageRefreshAll ;
                		Delay(1);	! Delay is just for demonstration purpose, such that you can
                				! see the progress (otherwise it would go too fast).
                	endfor ;
                
                	DialogMessage("The Batch Run is finished.") ;
            }
        }
        Procedure DeleteCases {
            Body: {
                CaseSelect(CaseToBeDeleted, "Select the output case that you want to delete") ;
                
                if CaseType(CaseToBeDeleted) = 'Input Identifiers' then
                
                   DialogMessage("The selected case is an input case and will therefore not be deleted. This to ensure that you can still use this example. If you really want to delete this case, you can delete it from within the Data Manager.") ;
                   halt ;
                
                endif ;
                
                CaseDelete(CaseToBeDeleted) ;
            }
            ElementParameter CaseToBeDeleted {
                Range: AllCases;
            }
        }
        DeclarationSection BatchRun_Declaration {
            ElementParameter CaseType {
                IndexDomain: (IndexCases);
                Range: AllCaseTypes;
                InitialData: '';
            }
            Set InputCases {
                SubsetOf: AllCases;
                Definition: {
                    {IndexCases | CaseType(IndexCases) = 'Input Identifiers' }
                }
            }
            Set BatchRunCases {
                SubsetOf: InputCases;
                Index: bc;
            }
            Set OutputCases {
                SubsetOf: AllCases;
                Index: oc;
            }
            Parameter ObjResult {
                IndexDomain: oc;
                Unit: $;
            }
        }
    }
    Section Compare_Cases_Section {
        DeclarationSection Compare_Cases_Declaration {
            ElementParameter CaseToCompare {
                Range: AllCases;
                Default: 0;
            }
            ElementParameter OneModeToCompareAll {
                Range: AllDifferencingModes;
                Default: '';
                InitialData: 'Elementreplacement';
            }
            ElementParameter ModeToCompare {
                IndexDomain: (a);
                Range: AllDifferencingModes;
                Definition: OneModeToCompareAll;
            }
            StringParameter ModeDescription {
                IndexDomain: IndexDifferencingModes;
                Definition: {
                    data
                    { blockReplacement   : "When there are differences between the reference case and the current case for an identifier the data of that identifier in the current case is entirely displayed.",
                      elementReplacement : "When there are differences between the reference case and the current case for an identifier the differing elements in the current case are displayed. This may include defaults for elements deleted.",
                      elementAddition    : "When there are differences between the reference case and the current case for an identifier the differences between elements in the current case and reference case are displayed.",
                      elementMultiplication : "When there are differences between the reference case and the current case for an identifier the relative differences between elements in the current case and reference case are displayed."
                      }
                }
            }
            Set TotalSetIdentifiersToCompare {
                SubsetOf: AllIdentifiers;
                Definition: {
                    data
                        { Volume                   , Surface                  , Money                    , Mass                     ,
                          Products                 , Materials                , MaterialUnit             , ProductUnit              ,
                          MaterialContentsInProduct, MaterialCost             , AvailableMaterial        , Demand                   ,
                          Revenue                  , ProductCost              , Production               , ProductionCost           ,
                          Profit                   , ObjectiveValue           , MaterialUsed             }
                }
            }
            Set IdentifiersToCompare {
                SubsetOf: TotalSetIdentifiersToCompare;
                Index: a;
                InitialData: TotalSetIdentifiersToCompare;
            }
            Parameter CaseTypeToCompare {
                IndexDomain: (IndexCaseTypes);
            }
            StringParameter DifferenceFile {
                Definition: "Differences.txt";
            }
        }
        Procedure SelectAll {
            Body: {
                IdentifiersToCompare := TotalSetIdentifiersToCompare ;
            }
        }
        Procedure UnselectAll {
            Body: {
                IdentifiersToCompare := {} ;
            }
        }
        Procedure Compare_Cases {
            Body: {
                if CaseToCompare = '' then
                
                   DialogMessage("No case selected.") ;
                
                endif ;
                
                if OneModeToCompareAll = '' then
                
                   DialogMessage("No mode selected.") ;
                
                endif ;
                
                if IdentifiersToCompare = {} then
                
                   DialogMessage("No identifiers selected.") ;
                
                endif ;
                
                if not (CaseToCompare = '' or OneModeToCompareAll = '' or IdentifiersToCompare = {} ) then
                
                   CaseCreateDifferenceFile( CaseToCompare, DifferenceFile, ModeToCompare(a) ) ;
                
                endif ;
                
                PageRefreshAll ;
            }
        }
        Procedure ReadDifferenceFile {
            Body: {
                if DialogAsk("The selected case will be loaded, after which the differences will be applied to the case. The case will not be saved automatically. Do you want to continue?", "Yes", "No") = 1 then
                
                   CaseLoadCurrent(CaseToCompare, 0) ;
                
                   read from file DifferenceFile ;
                
                endif ;
            }
        }
    }
    Section Multiple_Case_Section {
        Procedure InitializeCaseSelection {
            Body: {
                if ( CurrentCaseSelection = {} AND
                     7 in AllCases AND
                     8 in AllCases AND
                     9 in AllCases ) then
                	CurrentCaseSelection := { 7,8,9 } ;
                endif ;
            }
        }
        DeclarationSection Multiple_Case_Declaration {
            Parameter MultipleCaseProduction {
                IndexDomain: (IndexCurrentCaseSelection,p);
                Definition: {
                    if CurrentDataset('Constant Input') = CaseConstantDataset(IndexCurrentCaseSelection) then
                    	IndexCurrentCaseSelection.Production(p)
                    endif
                }
            }
            ElementParameter CaseConstantDataset {
                IndexDomain: IndexCurrentCaseSelection;
                Range: AllDataSets;
                Definition: CaseGetDatasetReference(IndexCurrentCaseSelection, 'Constant Input', CaseConstantDataset(IndexCurrentCaseSelection));
            }
        }
    }
    Procedure MainInitialization {
        Body: {
            for IndexDataFiles do
            	DataFileGetName(IndexDataFiles, DataFileName(IndexDataFiles))
            endfor ;
        }
    }
    Procedure MainExecution {
        Body: {
            ! The model is solved using the current data.
            
            	solve MaximizeProfit ;
            
            ! The output is saved in an output case:
            
            	CurrentDefaultCaseType := 'Output Identifiers' ;
            
            	CaseName := FormatString("Output %s",
            			DataFileName(CurrentDataset('Variable Input'))) ;
            	CasePath := FormatString("%s\\Output\\%s",
            			DataFileName(CurrentDataset('Constant Input')),
            			CaseName) ;
            
            	! When the case with name CaseName in path CasePath does not yet
            	! exist, this case will be created:
            
            	if not CaseFind(CasePath,ThisCase) then
            		CaseCreate(CasePath, ThisCase) ;
            		DataFileName(ThisCase) := CaseName ;
            	endif ;
            
            	! The output case (ThisCase) is set as the current case and the
            	! data is saved in the current case.
            
            	CaseSetCurrent(ThisCase) ;
            	CaseSave(0) ;
            
            	CurrentDefaultCaseType := '' ;
        }
    }
    Procedure MainTermination {
        Body: {
            return 1;
        }
    }
}
