
MAIN MODEL Dice_Model
  comment :  "Finding multiple solutions for the dice problem
              
              Problem type:
              MIP (small)
              
              Description:
              This example demonstrates several approaches to get multiple solutions when
              solving a MIP problem. These approaches are:
              - Using the incumbent (solver) callback;
              - Using the solution pool (only supported by CPLEX);
              - Repeatedly solve problem forbidding the previous solutions.
              
              In the dice problem a set of three dice has to be designed by assigning an
              integer number to each face such that on average dice 1 beats dice 2, dice
              2 beats dice 3 and dice 3 beats dice 1. The goal is to maximize the number
              of total wins on average. The dice problem has many solutions.
              
              References:
              Paul van der Eijk"

  DECLARATION SECTION Declaration_Model

    SET:
       identifier   :  Faces
       text         :  "Faces on a dice"
       indices      :  f, fp
       initial data :  data { face1 .. face6 } ;

    SET:
       identifier   :  Dice
       index        :  i
       initial data :  data { dice1 .. dice3 } ;

    PARAMETER:
       identifier   :  LowestFaceValue
       text         :  "Lowest face value"
       initial data :  1 ;

    PARAMETER:
       identifier   :  HighestFaceValue
       text         :  "Highest face value" ;

    VARIABLE:
       identifier   :  Obj
       comment      :  "Number of wins." ;

    VARIABLE:
       identifier   :  FaceValue
       index domain :  (i,f)
       range        :  binary
       comment      :  "Face value of dice." ;

    VARIABLE:
       identifier   :  MatchOutcome
       index domain :  (i,f,fp)
       range        :  binary
       comment      :  "Binary variable indicating whether face f of dice i wins (value 1) or loses (value 0)
                        against face fp of dice i+1 (circular)." ;

    CONSTRAINT:
       identifier   :  WinsConstraint
       index domain :  i
       definition   :  Obj = sum( (f,fp), MatchOutcome(i,f,fp) )
       comment      :  "Count the wins of all dice." ;

    CONSTRAINT:
       identifier   :  MatchOutcomeConstraint
       index domain :  (i,f,fp)
       definition   :  FaceValue(i,f) + (HighestFaceValue-LowestFaceValue)*(1-MatchOutcome(i,f,fp)) >= FaceValue(i++1,fp) + 1
       comment      :  "Constraint that determines whether face f of dice i wins (value 1) or loses (value 0)
                        against face fp of dice i+1, as indicated by the binary variable MatchOutcome. Note
                        that MatchOutcome is non-transitive." ;

    CONSTRAINT:
       identifier   :  FaceValuesConstraint
       index domain :  (i,f) | (f-1) in faces
       definition   :  FaceValue(i,f-1) + 1 <= FaceValue(i,f)
       comment      :  "Constraint to enforce that each single dice gets different face values." ;

    MATHEMATICAL PROGRAM:
       identifier   :  DiceMP
       objective    :  Obj
       direction    :  maximize
       constraints  :  AllConstraints
       variables    :  AllVariables
       type         :  MIP ;

  ENDSECTION  ;

  PROCEDURE
    identifier :  MainInitialization
    body       :  
      HighestFaceValue := card(Dice) * card(faces);
      
      FaceValue.lower(i,f) := LowestFaceValue;
      FaceValue.upper(i,f) := HighestFaceValue;
      
      FaceValue.lower('dice1','face1') := LowestFaceValue;
      FaceValue.upper('dice1','face1') := LowestFaceValue;
      FaceValue.level('dice1','face1') := LowestFaceValue;
      
      SolutionMethod := 'normal';

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  MainExecution
    comment    :  "Normal solve; returns one (optimal) solution."
    body       :  
      empty Objs, FaceValues;
      
      ! Optimal objective value: 21.
      solve DiceMP;
      
      Objs(1) := Obj;
      FaceValues(i,f,1) := FaceValue(i,f);

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  MainTermination
    body       :  
      return 1;

  ENDPROCEDURE  ;

  SECTION Multiple_Solutions


    DECLARATION SECTION Declaration_Solutions

      ELEMENT PARAMETER:
         identifier   :  myGMP
         range        :  AllGeneratedMathematicalPrograms ;

      PARAMETER:
         identifier   :  SolutionLimit
         range        :  integer
         definition   :  5
         comment      :  "Maximum number of solutions stored." ;

      PARAMETER:
         identifier   :  NumberOfSolutions
         comment      :  "Number of solutions stored." ;

      PARAMETER:
         identifier   :  SolutionCount
         comment      :  "The number of solutions found." ;

      SET:
         identifier   :  Solutions
         subset of    :  Integers
         index        :  s
         definition   :  { 1 .. SolutionLimit } ;

      PARAMETER:
         identifier   :  Objs
         index domain :  (s)
         comment      :  "Parameter to store the objective values for the solutions." ;

      PARAMETER:
         identifier   :  FaceValues
         index domain :  (i,f,s)
         text         :  "value of dice - will be integer"
         comment      :  "Parameter to store the face values for the solutions." ;

    ENDSECTION  ;

    PROCEDURE
      identifier :  SolverCallback
      comment    :  "Solve model using incumbent callback procedure. During the solving process the solver
                     will call this callback whenever it finds a new improved incumbent solution."
      body       :  
        empty Objs, FaceValues;
        
        SolutionCount := 0;
        
        myGMP := GMP::Instance::Generate( DiceMP );
        
        ! Install incumbent callback.
        GMP::Instance::SetCallbackNewIncumbent( myGMP, 'NewIncumbentCallback' );
        
        GMP::Instance::Solve( myGMP );
        
        ! Reomve incumbent callback.
        GMP::Instance::SetCallbackNewIncumbent( myGMP, '' );

    ENDPROCEDURE  ;

    PROCEDURE
      identifier :  NewIncumbentCallback
      arguments  :  solvSess

      DECLARATION SECTION 

        PARAMETER:
           identifier :  cnt ;

        ELEMENT PARAMETER:
           identifier :  solvSess
           range      :  AllSolverSessions
           property   :  Input ;

      ENDSECTION  ;

      comment    :  "Incumbent callback. The order of solutions is reversed such that the best
                     solutions are at the first positions in the solution repository."
      body       :  
        GMP::Solution::RetrieveFromSolverSession( solvSess, 1 );
        
        GMP::Solution::SendToModel( myGMP, 1 );
        
        SolutionCount += 1;
        
        cnt := min( SolutionCount, SolutionLimit );
        
        while ( cnt > 1 ) do
            Objs(cnt) := Objs(cnt-1);
            FaceValues(i,f,cnt) := FaceValues(i,f,cnt-1);
            cnt -= 1;
        endwhile;
        
        Objs(1) := Obj;
        FaceValues(i,f,1) := FaceValue(i,f);
        
        return 1;

    ENDPROCEDURE  ;

    PROCEDURE
      identifier :  SolutionPool
      comment    :  "Solve model using the solution pool which is only supported by CPLEX. The CPLEX option
                     'Do Populate' should be switched on to invoke the solution pool. The solution pool is
                     not necessarily filled with the best solutions. CPLEX offers several options for the
                     solution pool which gives you the possibility to control, e.g., the quality or the
                     diversity of the solutions.
                     
                     The solutions are stored in the solution repository of the GMP and after the solve
                     the solution values are copied from the solution repository to the parameters Objs
                     and FaceValues holding the variable values for the different solutions."
      body       :  
        empty Objs, FaceValues;
        
        myGMP := GMP::Instance::Generate( DiceMP );
        
        GMP::Instance::SetOptionValue( myGMP, 'do populate', 1 );
        
        GMP::Instance::Solve( myGMP );
        
        NumberOfSolutions := GMP::Solution::Count( myGMP );
        
        SolutionCount := 1;
        while ( SolutionCount <= min(NumberOfSolutions,SolutionLimit) ) do
            GMP::Solution::SendToModel( myGMP, SolutionCount );
        
            Objs(SolutionCount) := Obj;
            FaceValues(i,f,SolutionCount) := FaceValue(i,f);
        
            SolutionCount += 1;
        endwhile;
        
        GMP::Solution::SendToModel( myGMP, 1 );
        
        GMP::Instance::SetOptionValue( myGMP, 'do populate', 0 );

    ENDPROCEDURE  ;

    PROCEDURE
      identifier :  EliminationRows
      comment    :  "Repeatedly solve model eliminating the previously found solution (by adding rows
                     that forbid this solution). This approach returns the n best solutions. It is the
                     most time consuming approach in this example."
      body       :  
        empty Objs, FaceValues;
        
        myGMP := GMP::Instance::Generate( DiceMP );
        
        SolutionCount := 1;
        while ( SolutionCount <= SolutionLimit ) do
            GMP::Instance::Solve( myGMP );
        
            Objs(SolutionCount) := Obj;
            FaceValues(i,f,SolutionCount) := FaceValue(i,f);
        
            ! Eliminate previously found integer solution.
            GMP::Instance::AddIntegerEliminationRows( myGMP, 1, SolutionCount );
        
            SolutionCount += 1;
        endwhile;

    ENDPROCEDURE  ;

  ENDSECTION Multiple_Solutions ;

  SECTION Page


    DECLARATION SECTION 

      SET:
         identifier :  Methods
         definition :  { 'normal', 'callback', 'solution pool', 'elimination' } ;

      ELEMENT PARAMETER:
         identifier :  SolutionMethod
         range      :  Methods ;

    ENDSECTION  ;

    PROCEDURE
      identifier :  ButtonSelectionProcedure
      body       :  
        switch (SolutionMethod) do
                'normal':
                        MainExecution;
                'callback':
                        SolverCallback;
                'elimination':
                        EliminationRows;
                'solution pool':
                        SolutionPool;
        endswitch;

    ENDPROCEDURE  ;

  ENDSECTION Page ;

ENDMODEL Dice_Model ;
