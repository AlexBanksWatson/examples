
MAIN MODEL Main_NetworkDesign
  comment :  "Capacitated network design problem
              
              Problem type:
              MIP (hard)
              
              Description:
              Network design problems deal with the selection of a subset of edges in
              an existing network, such that for a set of commodities the given demand
              for each commodity can be transported from its origin to its destination,
              at minumum cost. In the capacitated network design problem the edges have
              (fixed) capacities. Network design problems arise in telecommunications
              and transportation planning.
              
              The data of the instances are read using XML files.
              
              References:
              Raack, C., A.M.C.A. Koster, S. Orlowski, R. Wessaly, On cut-based inequalities
              for capacitated network design polyhedra, Networks 57 (2), 2011, pp. 141-156.
              
              SNDlib: http://sndlib.zib.de/"

  DECLARATION SECTION Declaration_Data

    SET:
       identifier   :  LinkTypes
       definition   :  { 'DIRECTED', 'BIDIRECTED', 'UNDIRECTED' } ;

    ELEMENT PARAMETER:
       identifier   :  LinkModel
       range        :  LinkTypes ;

    SET:
       identifier   :  Demands
       index        :  q ;

    PARAMETER:
       identifier   :  Demand
       index domain :  q ;

    PARAMETER:
       identifier   :  SetupCost
       index domain :  (i,j) ;

    ELEMENT PARAMETER:
       identifier   :  FromCity
       index domain :  q
       range        :  Cities ;

    ELEMENT PARAMETER:
       identifier   :  ToCity
       index domain :  q
       range        :  Cities ;

    SET:
       identifier   :  Links
       index        :  l
       comment      :  "Dummy set needed to read XML file." ;

  ENDSECTION  ;

  DECLARATION SECTION Declaration_Model

    SET:
       identifier   :  Cities
       indices      :  i, j ;

    SET:
       identifier   :  Commodities
       subset of    :  Cities
       index        :  k ;

    PARAMETER:
       identifier   :  ModuleCost
       index domain :  (i,j) ;

    PARAMETER:
       identifier   :  ModuleCapacity
       index domain :  (i,j) ;

    PARAMETER:
       identifier   :  AggrDemand
       index domain :  (k,i) ;

    VARIABLE:
       identifier   :  Flow
       index domain :  (i,j,k) | ( ModuleCapacity(i, j) or ModuleCapacity(j, i) ) and k <> i
       range        :  nonnegative ;

    VARIABLE:
       identifier   :  NumberOfModules
       index domain :  (i,j) | ModuleCapacity(i, j)
       range        :  integer ;

    VARIABLE:
       identifier   :  TotalCost
       range        :  free
       definition   :  sum((i,j), NumberOfModules(i, j) * ModuleCost(i, j)) ;

    CONSTRAINT:
       identifier   :  DemandConstraint
       index domain :  (k,i)
       definition   :  sum(j, Flow(j, i, k)) - sum(j, Flow(i, j, k)) = AggrDemand(k,i)
       comment      :  "Flow conservation constraint" ;

    CONSTRAINT:
       identifier   :  CapacityConstraintDirected
       index domain :  (i,j) | ModuleCapacity(i, j)
                       and ( LinkModel = 'DIRECTED' or LinkModel = 'BIDIRECTED' )
       definition   :  sum(k, Flow(i, j, k)) <= ModuleCapacity(i, j) * NumberOfModules(i, j) ;

    CONSTRAINT:
       identifier   :  CapacityConstraintBidirected
       index domain :  (i,j) | ModuleCapacity(j, i)
                       and LinkModel = 'BIDIRECTED'
       definition   :  sum(k, Flow(i, j, k)) <= ModuleCapacity(j, i) * NumberOfModules(j, i) ;

    CONSTRAINT:
       identifier   :  CapacityConstraintUndirected
       index domain :  (i,j) | ModuleCapacity(i, j)
                       and LinkModel = 'UNDIRECTED'
       definition   :  sum(k, Flow(i, j, k) + Flow(j, i, k)) <= ModuleCapacity(i, j) * NumberOfModules(i, j) ;

    MATHEMATICAL PROGRAM:
       identifier   :  LeastCost
       objective    :  TotalCost
       direction    :  minimize
       constraints  :  AllConstraints
       variables    :  AllVariables
       type         :  Automatic ;

  ENDSECTION  ;

  DECLARATION SECTION Declaration_Benders_Decomposition

    ELEMENT PARAMETER:
       identifier :  myGMP
       range      :  AllGeneratedMathematicalPrograms ;

  ENDSECTION  ;

  PROCEDURE
    identifier :  MainInitialization

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  ReadAndProcessData
    body       :  
      ! The folder Input contains the following instances (in XML format):
      !   franceDBSNCANN, geantDBSNCANN, janos-usDDSNCANN, sunDDSNCANN.
      ! The instances are from SNDlib at http://sndlib.zib.de/home.action .
      
      ReadXML( "Input\\franceDBSNCANN.xml", "NetworkDesign.axm" );
      
      ! Unfortunately, the XML input files do not contain information on
      ! the link model so we have to assign it manually. Instances that
      ! contain 'DB' in their name use the BIDIRECTED link model; instances
      ! that contain 'DD' use the DIRECTED link model.
      
      LinkModel := 'BIDIRECTED';
      
      empty Commodities, AggrDemand;
      
      for (q) do
          Commodities += FromCity(q);
          AggrDemand(FromCity(q),FromCity(q)) += Demand(q);
          AggrDemand(FromCity(q),  ToCity(q)) -= Demand(q);
      endfor;

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  MainExecution
    body       :  
      ReadAndProcessData;
      
      solve LeastCost;

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  DoBendersDecomposition
    body       :  
      ReadAndProcessData;
      
      myGMP := GMP::Instance::Generate( LeastCost );
      
      GMPBenders::FeasibilityOnly := 1;
      GMPBenders::CreateStatusFile := 1;
      GMPBenders::DisplayInterval := 1;
      GMPBenders::TimeLimit := 10800;
      
      ! Possible Benders' modes are:
      !   'Classic', 'Modern', 'TwoPhaseClassic', 'TwoPhaseModern'
      ! The modes 'Modern' and 'TwoPhaseModern' can only be used by CPLEX and Gurobi.
      
      GMPBenders::DoBendersDecomposition( myGMP, AllIntegerVariables, 'Classic' );

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  MainTermination
    body       :  
      return 1;

  ENDPROCEDURE  ;

  MODULE GMP_Benders_Decomposition_Module
      source file :  "%AIMMSMODULES%\\GMPBendersDecomposition.aim"
    comment     :  "This module contains an implementation of an automatic Benders' Decomposition algorithm
                    using functions from the GMP library. It can be used to solve linear problems (LP and MIP).
                    
                    See the chapter Automatic Benders' Decomposition in the Language Reference for more
                    information."


  ENDMODULE GMP_Benders_Decomposition_Module ;

ENDMODEL Main_NetworkDesign ;
