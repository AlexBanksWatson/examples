
MAIN MODEL Dice_Model

  DECLARATION SECTION Declaration_Model
    comment    :  " Probabilistic dice - an example of a non-transitive relation.
                   
                    We want to design a set of dice with an integer number on each face
                    such that on average dice1 beats dice2, and dice2 on average beats
                    dice3 etc, but diceN has to beat dice1.
                   
                    MIP codes behave very erratic on such a problem and slight
                    reformulations can result in dramatic changes in performance. Also
                    note the face value will be integers automatically.
                   
                    submitted by:
                      Paul van der Eijk, GAMS Development Corporations"


    SET:
       identifier   :  faces
       text         :  "faces on a dice"
       indices      :  f, fp
       initial data :  data { face1 .. face6 } ;

    SET:
       identifier   :  dice
       text         :  "number of dice"
       index        :  i
       initial data :  data { dice1 .. dice3 } ;

    PARAMETER:
       identifier   :  flo
       text         :  "lowest face value"
       initial data :  1 ;

    PARAMETER:
       identifier   :  fup
       text         :  "highest face value" ;

    PARAMETER:
       identifier   :  wn
       text         :  "wins needed - possible bound" ;

    VARIABLE:
       identifier   :  obj
       text         :  "number of wins" ;

    VARIABLE:
       identifier   :  face_value
       index domain :  (i,f)
       text         :  "value of dice - will be integer"
       range        :  binary ;

    VARIABLE:
       identifier   :  comp
       index domain :  (i,f,fp)
       text         :  "one if f beats fp"
       range        :  binary ;

    CONSTRAINT:
       identifier   :  eq1
       index domain :  i
       text         :  "count the wins"
       definition   :  sum((f,fp), comp(i,f,fp)) = obj ;

    CONSTRAINT:
       identifier   :  eq3
       index domain :  (i,f,fp)
       text         :  "definition of non-transitive relation"
       definition   :  face_value(i,f) + (fup-flo)*(1-comp(i,f,fp)) >= face_value(i++1,fp) + 1 ;

    CONSTRAINT:
       identifier   :  eq4
       index domain :  (i,f) | (f-1) in faces
       text         :  "different face values for a single dice"
       definition   :  face_value(i,f-1) + 1 <= face_value(i,f) ;

    MATHEMATICAL PROGRAM:
       identifier   :  xdice
       objective    :  obj
       direction    :  maximize
       constraints  :  AllConstraints
       variables    :  AllVariables
       type         :  MIP ;

  ENDSECTION  ;

  DECLARATION SECTION Declaration_Solutions

    ELEMENT PARAMETER:
       identifier   :  myGMP
       range        :  AllGeneratedMathematicalPrograms ;

    PARAMETER:
       identifier   :  MaxSolutions
       range        :  integer
       definition   :  5 ;

    PARAMETER:
       identifier   :  NrSolutions ;

    PARAMETER:
       identifier   :  cnt ;

    SET:
       identifier   :  Solutions
       subset of    :  Integers
       index        :  s
       definition   :  { 1 .. MaxSolutions } ;

    PARAMETER:
       identifier   :  obj_p
       index domain :  (s) ;

    PARAMETER:
       identifier   :  face_value_p
       index domain :  (i,f,s)
       text         :  "value of dice - will be integer" ;

  ENDSECTION  ;

  PROCEDURE
    identifier :  MainInitialization
    body       :  
      fup := card(dice) * card(faces);
      wn := floor(0.5 * sqr(card(faces))) + 1;
      
      face_value.lower(i,f) := flo;
      face_value.upper(i,f) := fup;
      
      face_value.lower('dice1','face1') := flo;
      face_value.upper('dice1','face1') := flo;
      face_value.level('dice1','face1') := flo;
      
      solmethod := 'normal';

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  MainExecution
    body       :  
      empty obj_p, face_value_p;
      
      myGMP := GMP::Instance::Generate( xdice );
      
      ! Optimal objective value: 21.
      GMP::Instance::Solve( myGMP );
      
      obj_p(1) := obj;
      face_value_p(i,f,1) := face_value(i,f);

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  SolverCallback
    body       :  
      empty obj_p, face_value_p;
      
      cnt := 1;
      
      myGMP := GMP::Instance::Generate( xdice );
      
      GMP::Instance::SetCallbackNewIncumbent( myGMP, 'NewIncumbentCallback' );
      
      ! Optimal objective value: 21.
      GMP::Instance::Solve( myGMP );
      
      GMP::Instance::SetCallbackNewIncumbent( myGMP, '' );

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  NewIncumbentCallback
    arguments  :  solvSess

    DECLARATION SECTION 

      PARAMETER:
         identifier :  cntBis ;

      ELEMENT PARAMETER:
         identifier :  solvSess
         range      :  AllSolverSessions
         property   :  Input ;

    ENDSECTION  ;

    body       :  
      GMP::Solution::RetrieveFromSolverSession( solvSess, 1 );
      
      GMP::Solution::SendToModel( myGMP, 1 );
      
      cntBis := min( cnt, MaxSolutions );
      
      while ( cntBis > 1 ) do
          obj_p(cntBis) := obj_p(cntBis-1);
          face_value_p(i,f,cntBis) := face_value_p(i,f,cntBis-1);
          cntBis -= 1;
      endwhile;
      
      obj_p(1) := obj;
      face_value_p(i,f,1) := face_value(i,f);
      
      cnt += 1;
      
      return 1;

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  SolutionPool
    body       :  
      empty obj_p, face_value_p;
      
      myGMP := GMP::Instance::Generate( xdice );
      
      GMP::Instance::SetOptionValue( myGMP, 'do populate', 1 );
      
      ! Optimal objective value: 21.
      GMP::Instance::Solve( myGMP );
      
      NrSolutions := GMP::Solution::Count( myGMP );
      
      cnt := 1;
      while ( cnt <= min(NrSolutions,MaxSolutions) ) do
          GMP::Solution::SendToModel( myGMP, cnt );
      
          obj_p(cnt) := obj;
          face_value_p(i,f,cnt) := face_value(i,f);
      
          cnt += 1;
      endwhile;
      
      GMP::Solution::SendToModel( myGMP, 1 );
      
      GMP::Instance::SetOptionValue( myGMP, 'do populate', 0 );

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  EliminationRows
    body       :  
      empty obj_p, face_value_p;
      
      myGMP := GMP::Instance::Generate( xdice );
      
      cnt := 1;
      while ( cnt <= MaxSolutions ) do
          GMP::Instance::Solve( myGMP );
      
          obj_p(cnt) := obj;
          face_value_p(i,f,cnt) := face_value(i,f);
      
          ! Eliminate previous found integer solution.
          GMP::Instance::AddIntegerEliminationRows( myGMP, 1, cnt );
      
          cnt += 1;
      endwhile;

  ENDPROCEDURE  ;

  PROCEDURE
    identifier :  MainTermination
    body       :  
      return 1;

  ENDPROCEDURE  ;

  SECTION Page


    DECLARATION SECTION 

      SET:
         identifier :  methods
         definition :  { 'normal', 'callback', 'solution pool', 'elimination' } ;

      ELEMENT PARAMETER:
         identifier :  solmethod
         range      :  methods ;

    ENDSECTION  ;

    PROCEDURE
      identifier :  ButtonProcedure
      body       :  
        if (solmethod = 'normal') then
            MainExecution;
        elseif (solmethod = 'callback') then
            SolverCallback;
        elseif (solmethod = 'elimination') then
            EliminationRows;
        else
            SolutionPool;
        endif

    ENDPROCEDURE  ;

  ENDSECTION Page ;

ENDMODEL Dice_Model ;
